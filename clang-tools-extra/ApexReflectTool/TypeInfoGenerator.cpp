#include "TypeInfoGenerator.h"
#include "Utils.h"

#include <fmt/core.h>
#include <fmt/format.h>
#include <fmt/os.h>

#include <string_view>
#include <iostream>
#include <sstream>

#include <clang/AST/QualTypeNames.h>
#include <clang/ASTMatchers/ASTMatchers.h>
#include <clang/Frontend/CompilerInstance.h>
#include <clang/Lex/Preprocessor.h>

namespace Reflect {

	constexpr std::string_view GENERATED_EXTENSION = ".reflect.cpp";

	namespace Templates {

	constexpr std::string_view PREAMBLE = R"(// Generated by ApexReflectTool for {file}
// Include for runtime type reflection
#include "Type.h"
#include "Field.h"
#include "Function.h"
#include "ClassStorage.h"
#include "TypeImpl.hpp"
#include "FunctionImpl.h"
#include "ParamerInfoImpl.h"

#ifndef NDEBUG
#include <cstdio>
#define LOG_DEBUG(fmt, ...) printf(fmt "\n", __VA_ARGS__)
#else
#define LOG_DEBUG()
#endif

// Includes from {file}
)";

	constexpr std::string_view DEPENDENCY = R"(
extern template Type* GetType<{type}>();
)";

	constexpr std::string_view CLASS = R"(
template <>
struct ClassImpl<{class}> : public _ClassImpl<{class}>, public detail::ClassStorage<{class}, {numbases}, {numfields}, {numfuncs}, {numtemplargs}>
{{
    DEFINE_TYPE_NAME({class})

    ClassImpl()
	{{
		_InitializeStorage(*this);

		m_Size = sizeof({class});
)";

	constexpr std::string_view FIELD = R"(
		{{
			auto& field = m_field_beg[{field_idx}]; // AddField();
			field.m_Name = "{field}";
			field.m_Type = GetType<{type}>();
			field.m_Offset = offsetof({class}, {field});
			field.m_ParentClass = this;
		}}
)";

	constexpr std::string_view METHOD = R"(
		{{
			using FnType = {type};
			using FnPtrType = FnType({fn_ptr_type}*);

			static ParamInfos _paraminfos {{
{method_param_list_items}
			}};

			static detail::FunctionImpl<FnPtrType, InvokePolicy::eDefaultInvoke, decltype(_paraminfos)>
				_func{{ "{func}", static_cast<FnPtrType>(&{class}::{func}), _paraminfos, this }};

			m_func_beg[{func_idx}] = Function(&_func);
		}}
)";

	constexpr std::string_view METHOD_PARAM_LIST_ITEM = 
R"(				detail::ParameterInfoImpl<{param_type}, {param_idx}, {param_default_type}>{{ "{param_name}" }},
)";

	constexpr std::string_view CLASS_EPILOGUE = R"(
		REGISTER_CLASS({class});
		LOG_DEBUG("[INIT] :: CLASS :: {class}");
	}}
}};

namespace {{ static ClassImpl<{class}> _class_{class_var}; }}

template <>
Class* GetClassImpl(TypeTag<{class}>)
{{
    return &_class_{class_var};
}}

template Class* GetClass<{class}>();
template Type* GetType<{class}>();
)";

	constexpr std::string_view ENUM = R"(
template <>
struct EnumImpl<{enum}> : public _EnumImpl<{enum}>
{{
	DEFINE_TYPE_NAME({enum})

	EnumImpl()
	{{
		m_NumValues = {count};
		REGISTER_ENUM({enum});
		LOG_DEBUG("[INIT] :: ENUM :: {enum}");
	}}

	DEFINE_ENUM_NAME_OF({enum})

	constexpr static bool is_contiguous = {isContiguous};

	const std::string_view* GetNames() const override
	{{
		return NAMES;
	}}

	Any GetValueAt(size_t idx) const override
	{{
		return VALUES[idx];
	}}

	constexpr static std::string_view NAMES[] = {{
{enum_names_list_items}
	}};

	constexpr static {enum} VALUES[] = {{
{enum_values_list_items}
	}};

}};

namespace {{ static EnumImpl<{enum}> _enum_{enum_var}; }}

template <>
Enum* GetEnumImpl(TypeTag<{enum}>)
{{
	return &_enum_{enum_var};
}}

template Enum* GetEnum<{enum}>();
template Type* GetType<{enum}>();
)";

	constexpr std::string_view ENUM_NAME_LIST_ITEM =
R"(		"{enum_list_item}",
)";
	constexpr std::string_view ENUM_VALUE_LIST_ITEM =
R"(		{enum_list_item},
)";

	}

	static std::string GetOutputFileName(llvm::StringRef filename)
	{
		if (filename.consume_back_insensitive(".cpp")
			|| filename.consume_back_insensitive(".hpp")
			|| filename.consume_back_insensitive(".h")) {
			return filename.str() + GENERATED_EXTENSION.data();
		}
		return filename.str() + GENERATED_EXTENSION.data();
	}

	TypeInfoGenerator::TypeInfoGenerator(
            const detail::ReflectionRegistry &registry,
            const llvm::StringRef &source_filename)
            : Generator(registry, source_filename),
			  gen_file(std::move(GetOutputFileName(source_filename))),
			  os(std::move(fmt::output_file(gen_file)))
	{
	}

	TypeInfoGenerator::~TypeInfoGenerator()
	{
		std::cout << "Flushed to " << gen_file << '\n';
		os.close();
	}

	bool TypeInfoGenerator::GeneratePreamble()
	{
		auto filename = m_SourceFilename.substr(m_SourceFilename.find_last_of("/\\") + 1);
		os.print(Templates::PREAMBLE, fmt::arg("file", filename));

		auto extension = m_SourceFilename.substr(m_SourceFilename.find_last_of(".") + 1);
		if (extension == "h" || extension == "hpp" || extension == "hxx") {
			// File is a header file
			os.print("#include \"{}\"\n", filename);
		} else {
			// File is a source file
			clang::SourceManager& sm = m_Context->getSourceManager();
			clang::FileID fid = sm.getMainFileID();

			for (auto it = sm.fileinfo_begin(); it != sm.fileinfo_end(); ++it) {
				clang::SourceLocation includeLoc = sm.getIncludeLoc(sm.translateFile(it->first));
				if (includeLoc.isValid() && sm.isInFileID(includeLoc, fid)) {
					auto endLoc = clang::Lexer::getLocForEndOfToken(includeLoc, 0, sm, m_Context->getLangOpts());
					llvm::StringRef include_filename = clang::Lexer::getSourceText(clang::CharSourceRange::getTokenRange(includeLoc, endLoc), sm, m_Context->getLangOpts());
					os.print("#include {}\n", include_filename);
				}
			}
		}

		for (const detail::Class& dep : m_Registry->dependencies) {
			 os.print(Templates::DEPENDENCY, fmt::arg("type", dep.clang_Decl->getQualifiedNameAsString()));
		}

		return true;
	}

	bool TypeInfoGenerator::GenerateClass(const detail::Class &c)
	{
		os.print(Templates::CLASS,
			fmt::arg("class", c.clang_Decl->getQualifiedNameAsString()),
			fmt::arg("numbases", 0), // TODO
			fmt::arg("numfields", c.NumFields()),
			fmt::arg("numfuncs", c.NumFuncs()),
			fmt::arg("numtemplargs", 0)
		);
		return true;
	}

	bool TypeInfoGenerator::GenerateField(const detail::Field& f)
	{
		auto typeStr = util::GetFullyQualifiedName(f.clang_Decl->getType(), *m_Context);
		
		std::cout << "[F] " << f.clang_Decl->getNameAsString() << " : " << typeStr << '\n';

		os.print(Templates::FIELD,
			fmt::arg("class", f.ParentClass().clang_Decl->getQualifiedNameAsString()),
			fmt::arg("field", f.clang_Decl->getName()),
			fmt::arg("type", typeStr),
			fmt::arg("field_idx", f.Index())
		);

		return true;
	}

	bool TypeInfoGenerator::GenerateFunction(const detail::Function& f)
	{
		auto typeStr = util::GetFullyQualifiedName(f.clang_Decl->getReturnType(), *m_Context);
		typeStr += "(";

		std::stringstream ssParamList;
		size_t param_idx = 0;
		for (clang::ParmVarDecl* param : f.clang_Decl->parameters()) {
			auto paramTypeStr = util::GetFullyQualifiedName(param->getType(), *m_Context);
			ssParamList << fmt::format(Templates::METHOD_PARAM_LIST_ITEM,
				fmt::arg("param_idx", param_idx),
				fmt::arg("param_name", param->getNameAsString()),
				fmt::arg("param_type", paramTypeStr),
				fmt::arg("param_default_type", param->hasDefaultArg() ? "void" : "void")
			);

			if (param_idx != 0)
				typeStr += ",";
			typeStr += paramTypeStr;

			++param_idx;
		}
		typeStr += ")";

		if (auto methodType = clang::cast<clang::CXXMethodDecl>(f.clang_Decl)) {
			typeStr += methodType->isConst() ? " const" : "";
		}

		std::cout << "[M] " << f.clang_Decl->getNameAsString() << " : " << typeStr << '\n';

		auto parentClass = f.ParentClass().clang_Decl->getQualifiedNameAsString();

		os.print(Templates::METHOD,
			fmt::arg("class", parentClass),
			fmt::arg("func", f.clang_Decl->getNameAsString()),
			fmt::arg("fn_ptr_type", f.clang_Decl->isStatic() ? "" : parentClass + "::"),
			fmt::arg("type", typeStr),
			fmt::arg("func_idx", f.Index()),
			fmt::arg("method_param_list_items", ssParamList.str())
		);

		return true;
	}

	bool TypeInfoGenerator::GenerateClassEpilogue(const detail::Class& c)
	{
		std::string className = c.clang_Decl->getQualifiedNameAsString();
		std::string classVarName = util::TypeVarName(className);
		os.print(Templates::CLASS_EPILOGUE,
			fmt::arg("class", c.clang_Decl->getQualifiedNameAsString()),
			fmt::arg("class_var", classVarName)
		);
		return true;
	}

	bool Reflect::TypeInfoGenerator::GenerateEnum(const detail::Enum & e)
	{
		std::string enumName = e.clang_Decl->getQualifiedNameAsString();

		std::stringstream ssNameList, ssValueList;
		size_t count = 0;
		bool isContiguous = true;
		int64_t prev;
		for (clang::EnumConstantDecl* en : e.clang_Decl->enumerators()) {
			ssNameList << fmt::format(Templates::ENUM_NAME_LIST_ITEM, fmt::arg("enum_list_item", en->getNameAsString()));
			ssValueList << fmt::format(Templates::ENUM_VALUE_LIST_ITEM, fmt::arg("enum_list_item", en->getQualifiedNameAsString()));
			
			if (isContiguous) {
				int64_t curr = en->getInitVal().getExtValue();
				 if (count > 0) {
					auto diff = (curr - prev);
					isContiguous = (diff == 1);
				}
				prev = curr;
			}
			++count;
		}

		auto enumVarName = util::TypeVarName(enumName);

		os.print(Templates::ENUM,
			fmt::arg("enum", enumName),
			fmt::arg("enum_var", enumVarName),
			fmt::arg("count", count),
			fmt::arg("isContiguous", isContiguous ? "true" : "false"),
			fmt::arg("enum_names_list_items", ssNameList.str()),
			fmt::arg("enum_values_list_items", ssValueList.str())
		);


		return true;
	}

}